// Copyright (c) 2018-2019 Coinbase, Inc. <https://coinbase.com/>
// Licensed under the Apache License, version 2.0

package com.coinbase.walletlink.daos

import com.coinbase.wallet.store.interfaces.StoreInterface
import com.coinbase.wallet.store.models.StoreKeys
import com.coinbase.walletlink.extensions.sessions
import com.coinbase.walletlink.models.Session
import io.reactivex.Observable
import java.net.URL
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

class SessionDAO(private val store: StoreInterface) {
    private val accessLock = ReentrantLock()

    /**
     * Get stored sessions
     */
    val sessions: List<Session> get() = getStoredSessions()

    /**
     * Get stored sessions filtered by url
     *
     * @param url URL to filter sessions
     *
     * @return Sessions for given URL
     */
    fun getSessions(url: URL): List<Session> = getStoredSessions().filter { it.url == url }

    /**
     * Get stored session for given sessionID and rpc URL
     *
     * @param id Session ID
     * @param url URL to filter sessions
     *
     * @returns Sessions for given URL
     */
    fun getSession(id: String, url: URL): Session? = getStoredSessions().firstOrNull { it.url == url && it.id == id }

    /**
     * Store session/secret to shared preferences using Android KeyStore
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     * @param secret Secret generated by the host
     * @param version WalletLink server version
     * @param dappName DApp name that initiated the new wallet link connection
     * @param dappImageURL DApp image that initiated the new wallet link connection
     * @param dappURL DApp URL that initiated the wallet link connection
     */
    fun save(
        url: URL,
        sessionId: String,
        secret: String,
        version: String?,
        dappName: String?,
        dappImageURL: URL?,
        dappURL: URL?
    ) = accessLock.withLock {
        val sessions = (store.get(StoreKeys.sessions) ?: emptyArray())
            .filter { it.id != sessionId && it.url != url }.toMutableList()

        val session = Session(
            id = sessionId,
            secret = secret,
            url = url,
            version = version,
            dappName = dappName,
            dappImageURL = dappImageURL,
            dappURL = dappURL
        )

        sessions.add(session)

        store.set(StoreKeys.sessions, sessions.toTypedArray())
    }

    /**
     * Deletes sessionID from keychain
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     */
    fun delete(url: URL, sessionId: String) = accessLock.withLock {
        val sessionIds = (store.get(StoreKeys.sessions) ?: arrayOf())
            .filter { it.id != sessionId || it.url != url }.toMutableList()

        store.set(StoreKeys.sessions, sessionIds.toTypedArray())
    }

    /**
     * Observe for all sessions updates
     *
     * @return [Observable] of all sessions
     */
    fun observeSessions(): Observable<List<Session>> = store.observe(StoreKeys.sessions)
        .map { it.toNullable()?.toList() ?: emptyList() }
        .distinctUntilChanged()

    /**
     * Observe for distinct stored sessionIds update
     *
     * @param url URL to filter sessions
     *
     * @return Session observable for given URL
     */
    fun observeSessions(url: URL): Observable<List<Session>> = store.observe(StoreKeys.sessions)
        .map { list -> list.toNullable()?.filter { it.url == url }?.sortedBy { it.id } ?: emptyList() }
        .distinctUntilChanged()

    // Private helpers

    private fun getStoredSessions(): List<Session> = accessLock
        .withLock { store.get(StoreKeys.sessions)?.toList() ?: listOf() }
        .sortedBy { it.id }
}
