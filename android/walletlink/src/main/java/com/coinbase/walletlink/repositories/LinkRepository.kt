// Copyright (c) 2018-2019 Coinbase, Inc. <https://coinbase.com/>
// Licensed under the Apache License, version 2.0

package com.coinbase.walletlink.repositories

import android.content.Context
import com.coinbase.wallet.core.extensions.asBigInteger
import com.coinbase.wallet.core.extensions.asHexEncodedData
import com.coinbase.wallet.core.extensions.asJsonMap
import com.coinbase.wallet.core.extensions.justNull
import com.coinbase.wallet.core.extensions.zipOrEmpty
import com.coinbase.wallet.core.util.Optional
import com.coinbase.wallet.crypto.extensions.decryptUsingAES256GCM
import com.coinbase.wallet.libraries.databases.db.Database
import com.coinbase.wallet.libraries.databases.model.DiskOptions
import com.coinbase.wallet.store.Store
import com.coinbase.walletlink.WalletLinkDatabase
import com.coinbase.walletlink.apis.WalletLinkAPI
import com.coinbase.walletlink.daos.DappDAO
import com.coinbase.walletlink.daos.SessionDAO
import com.coinbase.walletlink.dtos.RequestEthereumAccountsParams
import com.coinbase.walletlink.dtos.ServerRequestDTO
import com.coinbase.walletlink.dtos.SignEthereumMessageParams
import com.coinbase.walletlink.dtos.SignEthereumTransactionParams
import com.coinbase.walletlink.dtos.SubmitEthereumTransactionParams
import com.coinbase.walletlink.dtos.Web3RequestCanceledDTO
import com.coinbase.walletlink.dtos.Web3RequestDTO
import com.coinbase.walletlink.dtos.fromJson
import com.coinbase.walletlink.models.Dapp
import com.coinbase.walletlink.models.HostRequest
import com.coinbase.walletlink.models.HostRequestId
import com.coinbase.walletlink.models.EventType
import com.coinbase.walletlink.models.RequestMethod
import com.coinbase.walletlink.models.Session
import io.reactivex.Observable
import io.reactivex.Single
import io.reactivex.disposables.CompositeDisposable
import io.reactivex.rxkotlin.Singles
import io.reactivex.rxkotlin.addTo
import timber.log.Timber
import java.math.BigInteger
import java.net.URL
import javax.security.auth.Destroyable

internal class LinkRepository(context: Context) : Destroyable {
    private val disposeBag = CompositeDisposable()
    private val sessionDAO = SessionDAO(Store(context))
    private val api = WalletLinkAPI()
    private val dappDAO = {
        val option = DiskOptions(context, WalletLinkDatabase::class.java, "WalletLink")
        val database = Database(option)

        DappDAO(database = database)
    }()

    /**
     * Get list of session
     */
    val sessions: List<Session> get() = sessionDAO.sessions

    // Session Management

    /**
     * Get stored session for given sessionID and rpc URL
     *
     * @param id Session ID
     * @param url URL to filter sessions
     *
     * @return Sessions for given URL
     */
    fun getSession(id: String, url: URL): Session? = sessionDAO.getSession(id, url)

    /**
     * Get stored sessions filtered by url
     *
     * @param url URL to filter sessions
     *
     * @return Sessions for given URL
     */
    fun getSessions(url: URL): List<Session> = sessionDAO.getSessions(url)

    /**
     * Observe all sessions
     *
     * @return [Observable] of all sessions
     */
    fun observeSessions(): Observable<List<Session>> = sessionDAO.observeSessions()

    /**
     * Observe for distinct stored sessionIds update
     *
     * @param url URL to filter sessions
     *
     * @return Session observable for given URL
     */
    fun observeSessions(url: URL): Observable<List<Session>> = sessionDAO.observeSessions(url)

    /**
     * Deletes sessionID from keychain
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     */
    fun delete(url: URL, sessionId: String) = sessionDAO.delete(url, sessionId)

    /**
     * Store session/secret to shared preferences using Android KeyStore
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     * @param secret Secret generated by the host
     * @param version WalletLink server version
     * @param dappName DApp name that initiated the new wallet link connection
     * @param dappImageURL DApp image that initiated the new wallet link connection
     * @param dappURL DApp URL that initiated the wallet link connection
     */
    fun saveSession(
        url: URL,
        sessionId: String,
        secret: String,
        version: String?,
        dappName: String?,
        dappImageURL: URL?,
        dappURL: URL?
    ) = sessionDAO.save(
        url = url,
        sessionId = sessionId,
        secret = secret,
        version = version,
        dappName = dappName,
        dappImageURL = dappImageURL,
        dappURL = dappURL
    )

    // Dapp managment

    /**
     * Insert or update dapp
     *
     * @param dapp Dapp model to store
     *
     * @return A Single indicating the save operation success or an exception is thrown
     */
    fun saveDapp(dapp: Dapp): Single<Unit> = dappDAO.save(dapp)

    // MARK: - Request management

    /**
     * Mark requests as seen to prevent future presentation
     *
     * @param requestId WalletLink host generated request ID
     * @param url The URL for the session
     *
     * @return A single wrapping `Void` if operation was successful. Otherwise, an exception is thrown
     */
    fun markAsSeen(requestId: HostRequestId, url: URL): Single<Unit> {
        val session = sessionDAO.getSession(requestId.sessionId, url) ?: return Single.just(Unit)

        return api.markEventAsSeen(requestId.eventId, session.id, session.secret, url)
    }

    /**
     * Get pending requests for given sessionID. Canceled requests will be filtered out
     *
     * @param session WalletLink connection session
     *
     * @return List of pending requests
     */
    fun getPendingRequests(session: Session): Single<List<HostRequest>> = api.getUnseenEvents(session)
        .flatMap { requests ->
            requests
                .map { getHostRequest(it, session.url) }
                .zipOrEmpty()
                .map { hostRequests -> hostRequests.mapNotNull { it.toNullable() } }
        }
        .map { requests ->
            // build list of cancelation requests
            val cancelationRequests = requests.filter { it.hostRequestId.isCancelation }

            // build list of pending requests by filtering out canceled requests
            val pendingRequests = requests.filter { request ->
                val cancelationRequest = cancelationRequests.firstOrNull {
                    it.hostRequestId.canCancel(request.hostRequestId)
                } ?: return@filter true

                markCancelledEventAsSeen(request.hostRequestId, cancelationRequest.hostRequestId, session.url)

                return@filter false
            }

            pendingRequests
        }
        .onErrorReturn { emptyList() }

    /**
     * Convert `ServerRequestDTO` to `HostRequest` if possible
     *
     * @param dto Instance of `ServerRequestDTO`
     * @param url WalletLink server URL
     *
     * @return A single wrapping a `HostRequest` or nil if unable to convert
     */
    @Suppress("UNCHECKED_CAST")
    fun getHostRequest(dto: ServerRequestDTO, url: URL): Single<Optional<HostRequest>> {
        val session = getSession(dto.sessionId, url) ?: return Singles.justNull()

        try {
            val decrypted = dto.data.decryptUsingAES256GCM(secret = session.secret)
            val jsonString = decrypted.toString(Charsets.UTF_8)
            val json = jsonString.asJsonMap() ?: return Singles.justNull()

            return when (dto.event) {
                EventType.Web3Request -> {
                    val requestObject = json["request"] as? Map<String, Any> ?: return Singles.justNull()
                    val requestMethodString = requestObject["method"] as? String ?: return Singles.justNull()
                    val method = RequestMethod.fromRawValue(requestMethodString) ?: return Singles.justNull()

                    parseWeb3Request(dto, method, decrypted, url)
                }
                EventType.Web3Response -> { Singles.justNull() }
                EventType.Web3RequestCanceled -> {
                    parseWeb3Request(dto, RequestMethod.RequestCanceled, decrypted, url)
                }
            }
        } catch (exception: Exception) {
            Timber.e(exception)
        }

        return Singles.justNull()
    }

    // MARK: - Private

    private fun markCancelledEventAsSeen(
        requestId: HostRequestId,
        cancelationRequestId: HostRequestId,
        url: URL
    ) = markAsSeen(requestId, url)
        .flatMap { markAsSeen(cancelationRequestId, url) }
        .subscribe()
        .addTo(disposeBag)

    private fun parseWeb3Request(
        serverRequest: ServerRequestDTO,
        method: RequestMethod,
        decrypted: ByteArray,
        url: URL
    ): Single<Optional<HostRequest>> {
        when (method) {
            RequestMethod.RequestEthereumAccounts -> {
                return hostRequestId<RequestEthereumAccountsParams>(serverRequest, decrypted, url)
                    .map {
                        val hostRequestId = it.toNullable()?.second ?: return@map Optional(null)
                        Optional(HostRequest.DappPermission(hostRequestId))
                    }
            }
            RequestMethod.SignEthereumMessage -> {
                return hostRequestId<SignEthereumMessageParams>(serverRequest, decrypted, url)
                    .map {
                        val web3Request = it.toNullable()?.first ?: return@map Optional(null)
                        val hostRequestId = it.toNullable()?.second ?: return@map Optional(null)

                        Optional(
                            HostRequest.SignMessage(
                                hostRequestId = hostRequestId,
                                address = web3Request.request.params.address,
                                message = web3Request.request.params.message,
                                isPrefixed = web3Request.request.params.addPrefix,
                                typedDataJson = web3Request.request.params.typedDataJson
                            )
                        )
                    }
            }
            RequestMethod.SignEthereumTransaction -> {
                return hostRequestId<SignEthereumTransactionParams>(serverRequest, decrypted, url)
                    .map {
                        val web3Request = it.toNullable()?.first ?: return@map Optional(null)
                        val hostRequestId = it.toNullable()?.second ?: return@map Optional(null)
                        val weiValue = BigInteger(web3Request.request.params.weiValue)

                        Optional(
                            HostRequest.SignAndSubmitTx(
                                hostRequestId = hostRequestId,
                                fromAddress = web3Request.request.params.fromAddress,
                                toAddress = web3Request.request.params.toAddress,
                                weiValue = weiValue,
                                data = web3Request.request.params.data.asHexEncodedData() ?: ByteArray(size = 0),
                                nonce = web3Request.request.params.nonce,
                                gasPrice = web3Request.request.params.gasPriceInWei.asBigInteger,
                                gasLimit = web3Request.request.params.gasLimit.asBigInteger,
                                chainId = web3Request.request.params.chainId,
                                shouldSubmit = web3Request.request.params.shouldSubmit
                            )
                        )
                    }
            }
            RequestMethod.SubmitEthereumTransaction -> {
                return hostRequestId<SubmitEthereumTransactionParams>(serverRequest, decrypted, url)
                    .map {
                        val web3Request = it.toNullable()?.first ?: return@map Optional(null)
                        val hostRequestId = it.toNullable()?.second ?: return@map Optional(null)
                        val signedTx = web3Request.request.params.signedTransaction.asHexEncodedData()
                            ?: return@map Optional(null)

                        Optional(
                            HostRequest.SubmitSignedTx(
                                hostRequestId = hostRequestId,
                                signedTx = signedTx,
                                chainId = web3Request.request.params.chainId
                            )
                        )
                    }
            }
            RequestMethod.RequestCanceled -> {
                val web3Request = Web3RequestCanceledDTO.fromJson(decrypted) ?: return Single.just(Optional(null))

                return dappDAO.getDapp(web3Request.origin)
                    .map { dapp ->
                        val requestId = HostRequestId(
                            id = web3Request.id,
                            sessionId = serverRequest.sessionId,
                            eventId = serverRequest.eventId,
                            url = url,
                            dappURL = web3Request.origin,
                            dappImageURL = dapp.toNullable()?.logoURL,
                            dappName = dapp.toNullable()?.name,
                            method = RequestMethod.RequestCanceled
                        )

                        Optional(HostRequest.RequestCanceled(requestId))
                    }
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    inline fun <reified T> hostRequestId(
        serverRequest: ServerRequestDTO,
        decrypted: ByteArray,
        url: URL
    ): Single<Optional<Pair<Web3RequestDTO<T>, HostRequestId>>> {
        val web3Request = Web3RequestDTO.fromJson<T>(decrypted) ?: return Single.just(Optional(null))

        return dappDAO.getDapp(web3Request.origin)
            .map { dapp ->
                var dappImageURL = dapp.toNullable()?.logoURL
                var dappName = dapp.toNullable()?.name
                val params = web3Request.request.params as? RequestEthereumAccountsParams

                if (params != null) {
                    dappName = params.appName
                    dappImageURL = params.appLogoUrl
                }

                val requestId = HostRequestId(
                    id = web3Request.id,
                    sessionId = serverRequest.sessionId,
                    eventId = serverRequest.eventId,
                    url = url,
                    dappURL = web3Request.origin,
                    dappImageURL = dappImageURL,
                    dappName = dappName,
                    method = web3Request.request.method
                )

                Optional(Pair(web3Request, requestId))
            }
    }
}
